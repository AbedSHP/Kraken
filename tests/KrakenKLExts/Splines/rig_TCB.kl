require rig_Curves;

object CatRomSpline : Spline
{
  Vec3 cv[];
  CatmullRom curve;
  Float32 length;
  Float32 tension;
  Float32 continuity;
  Float32 bias;

  Vec3 _debugSamples[];
  Vec3 _debugHandles[];
  Vec3 _debugHandleLines[];
  Vec3 _inHandles[];
  Vec3 _outHandles[];
  Boolean _debug;
  Boolean _draw;
  UInt32 _version;
  UInt32 _lengthVersion;
};


// Default Constructor
inline CatRomSpline(Vec3 cv[])
{
  this.curve = CatmullRom();
  this.setCV(cv);
  this.length();
}


// ===================
// Internal Functions
// ===================
function CatRomSpline.incrementVersion()
{
  this._version++;
}


function CatRomSpline.setCV!(Vec3 cv[])
{
  this.cv = cv;
  this._inHandles.resize(this.cv.size());
  this._outHandles.resize(this.cv.size());
  this.calculateHandles();
  this.incrementVersion();

  if (this._debug) {
    this.setDebugArrays();
  }
}


function Float32 CatRomSpline.length!()
{
  if (this._lengthVersion != this._version || this._version == 0) {
    Integer step = 250;
    Vec3 pos;
    Vec3 prevPos;
    Float32 length = 0;

    for (Size i=0; i < step; i++)
    {
      Float32 t = Float32(i) / Float32(step);
      pos = this.evalPos(t);
      if (i > 0)
        length += (pos - prevPos).length();
      prevPos = pos;
    }

    this.length = length;
    this._lengthVersion = this._version;
  }

  return this.length;
}


function CatRomSpline.debug!(Boolean active)
{
  this._debug = active;
}


function CatRomSpline.draw!(Boolean active)
{
  this._draw = active;
}


function CatRomSpline.calculateHandles!()
{
  // Calculate First and Last Handles
  this._inHandles[0] = Vec3();
  this._outHandles[0] = Vec3();
  this._inHandles[this.cv.size() - 1] = Vec3();
  this._outHandles[this.cv.size() - 1] = Vec3();

  // Calculate middle handles
  for(Size i=1; i<this.cv.size() - 1; i++)
  {
    // In Handle
    Scalar tcbIn0 = ((1 - this.tension) * (1 + this.bias) * (1 - this.continuity)) / 2;
    Vec3 vIn0 = this.cv[i] - this.cv[i-1];

    Scalar tcbIn1 = ((1 - this.tension) * (1 - this.bias) * (1 + this.continuity)) / 2;
    Vec3 vIn1 = this.cv[i+1] - this.cv[i];

    this._inHandles[i] = (tcbIn0 * vIn0) + (tcbIn1 * vIn1);


    // Out Handle
    Scalar tcbOut0 = ((1 - this.tension) * (1 + this.bias) * (1 + this.continuity)) / 2;
    Vec3 vOut0 = this.cv[i] - this.cv[i-1];

    Scalar tcbOut1 = ((1 - this.tension) * (1 - this.bias) * (1 - this.continuity)) / 2;
    Vec3 vOut1 = this.cv[i+1] - this.cv[i];

    this._outHandles[i] = (tcbOut0 * vOut0) + (tcbOut1 * vOut1);
  }
}


function CatRomSpline.setDebugArrays!()
{

  this._debugSamples.resize(101);
  for(Size i=0; i<this._debugSamples.size(); i++) {
    this._debugSamples[i] = this.evalPos(Scalar(i) * 0.01);
  }

  Size handleCounter = 0;
  this._debugHandles.resize(this.cv.size() * 2);
  for(Size i=0; i<this.cv.size(); i++) {

    Vec3 inHandle = this.cv[i] + this._inHandles[i];
    this._debugHandles[handleCounter] = inHandle;

    Vec3 outHandle = this.cv[i] - this._outHandles[i];
    this._debugHandles[handleCounter+1] = outHandle;

    handleCounter += 2;
  }

  Size handleLineCounter = 0;
  this._debugHandleLines.resize(this.cv.size() * 4);
  for(Size i=0; i<this.cv.size(); i++) {

    this._debugHandleLines[handleLineCounter] = this.cv[i];
    Vec3 inHandle = this.cv[i] + this._inHandles[i];
    this._debugHandleLines[handleLineCounter+1] = inHandle;

    this._debugHandleLines[handleLineCounter+2] = this.cv[i];
    Vec3 outHandle = this.cv[i] - this._outHandles[i];
    this._debugHandleLines[handleLineCounter+3] = outHandle;

    handleLineCounter += 4;
  }
}

// ===================
// External Functions
// ===================
function UInt32 CatRomSpline.getCurrentCurve(Float32 U)
{
  Float32 curves = this.cv.size() - 1;
  Float32 splineTime = U * curves;
  UInt32 currentCurve = Math_min(floor(splineTime), curves - 1);

  return currentCurve;
}


function Float32 CatRomSpline.getSegmentU(Float32 U)
{
  // Rescale U position to curve
  UInt32 nbCurves = this.cv.size() - 1;
  Scalar uPerSegment = 1.0 / Scalar(nbCurves);
  Index segment = floor(U/uPerSegment);
  if(segment >= nbCurves)
    segment = nbCurves - 1;
  Float32 segmentU = (U - Scalar(segment) * uPerSegment) / uPerSegment;

  return segmentU;
}

function Vec3[4] CatRomSpline.getHandles!(Float32 U)
{
  Vec3 cv[4];
  UInt32 currentCurve = this.getCurrentCurve(U);

  cv[1] = this.cv[currentCurve];
  cv[0] = this._outHandles[currentCurve].negate() + this.cv[currentCurve];
  cv[3] = this._inHandles[currentCurve+1] + this.cv[currentCurve+1];
  cv[2] = this.cv[currentCurve+1];

  return cv;
}

function Vec3 CatRomSpline.evalPos!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalPosM(this.getSegmentU(U));
}


function Vec3 CatRomSpline.evalTan!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalTanM(this.getSegmentU(U));
}


function Vec3 CatRomSpline.evalNorm!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalTanM(this.getSegmentU(U));
}


function CatRomSpline.aabboxd()
{

}


function Vec3[] CatRomSpline.propagateNormal(
  io Vec3 initNorm,
  Vec3[] tangents)
{
  Vec3 stuff[];
  return stuff;
}


function CatRomSpline.twist(
  Vec3 endNorm,
  io Vec3[] normals,
  Vec3[] tangents)
{

}