require rig_Curves;

object BezierSpline : Spline
{
  Vec3 cv[];
  CubicBezier curve;
  Boolean _debug;
  Boolean _draw;
};


// Default Constructor
inline BezierSpline(Vec3 cv[])
{
  this.cv = cv;
  this.length();
  this.curve = CubicBezier();
}


// ===================
// Internal Functions
// ===================

function Float32 BezierSpline.length!()
{
  return this.length;
}

function BezierSpline.debug!(Boolean active)
{
  this._debug = active;
}

function BezierSpline.draw!(Boolean active)
{
  this._draw = active;
}
// ===================
// External Functions
// ===================
function UInt32 BezierSpline.getCurrentCurve(Float32 U)
{
  Float32 curves = (this.cv.size() - 1- this.cv.size()%3)/3;
  Float32 splineTime = U * curves;
  UInt32 currentCurve = Math_min(floor(splineTime), curves - 1);

  return currentCurve;
}


function Float32 BezierSpline.getSegmentU(Float32 U)
{
  // Rescale U position to curve
  UInt32 nbCurves = (this.cv.size() - 1 - this.cv.size()%3 )/3;
  Scalar uPerSegment = 1.0 / Scalar(nbCurves);
  Index segment = floor(U/uPerSegment);
  if(segment >= nbCurves)
    segment = nbCurves - 1;
  Float32 segmentU = (U - Scalar(segment) * uPerSegment) / uPerSegment;

  return segmentU;
}


function Vec3[4] BezierSpline.getHandles!(Float32 U)
{
  Vec3 cv[4];
  UInt32 currentCurve = this.getCurrentCurve(U);

  cv[0] = this.cv[currentCurve*3];
  cv[1] = this.cv[currentCurve*3+1];
  cv[2] = this.cv[currentCurve*3+2];
  cv[3] = this.cv[currentCurve*3+3];

  return cv;
}


function Vec3 BezierSpline.evalPos!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalPosM(this.getSegmentU(U));
}


function Vec3 BezierSpline.evalTan!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalTanM(this.getSegmentU(U));
}


function Vec3 BezierSpline.evalNorm!(Float32 U)
{
  this.curve.update(this.getHandles(U));

  return this.curve.evalTanM(this.getSegmentU(U));
}

function Mat44[] BezierSpline.evalFrame!(Float32[] U)
{
  Vec3 cv[4];
  Mat44 m[];

  for (Integer i = 0; i < U.size(); i++)
  {
    Float32 SegmentU = this.getSegmentU(U[i]);
    this.curve.update(this.getHandles(U[i]));
    Vec3 tr = this.curve.evalPosM(SegmentU);
    Vec3 x = this.curve.evalTanM(SegmentU);
    Vec3 y = this.curve.evalNormM(SegmentU);
    Vec3 z = x.cross(y);
    y = x.cross(z);
    //TODO : set the matrix

  }
  return m;
}

function BezierSpline.aabboxd()
{

}


function Vec3[] BezierSpline.propagateNormal(io Vec3 initNorm, Vec3[] tangents)
{
  Vec3 stuff[];
  return stuff;
}


function BezierSpline.twist(Vec3 endNorm, io Vec3[] normals, Vec3[] tangents)
{

}
