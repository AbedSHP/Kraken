/*
Solving the Nearest PoInteger-on-Curve Problem
and
A Bezier Curve-Based Root-Finder
by Philip J. Schneider
from "Graphics Gems", Academic Press, 1990
*/

 /* poInteger_on_curve.c    */



/*
 *  Forward declarations
 */
Vec3  NearestPoIntegerOnCurve();
static  Integer FindRoots();
static  Vec3  *ConvertToBezierForm();
static  Float64  ComputeXIntegerercept();
static  Integer ControlPolygonFlatEnough();
static  Integer CrossingCount();
static  Vec3  Bezier();
static  Vector2 V2ScaleII();

Integer     MAXDEPTH = 64;  /*  Maximum depth for recursion */

#define EPSILON (ldexp(1.0,-MAXDEPTH-1)) /*Flatness control value */
const DEGREE  3           /*  Cubic Bezier curve      */
const W_DEGREE 5          /*  Degree of eqn to find roots of */


/*
 *  main :
 *  Given a cubic Bezier curve (i.e., its control poIntegers), and some
 *  arbitrary poInteger in the plane, find the poInteger on the curve
 *  closest to that arbitrary poInteger.
 */
main()
{

 static Vec3 bezCurve[4] = {  /*  A cubic Bezier curve    */
    { 0.0, 0.0 },
    { 1.0, 2.0 },
    { 3.0, 3.0 },
    { 4.0, 2.0 },
    };
    static Vec3 arbPoInteger = { 3.5, 2.0 }; /*Some arbitrary poInteger*/
    Vec3  poIntegerOnCurve;        /*  Nearest poInteger on the curve */

    /*  Find the closest poInteger */
    poIntegerOnCurve = NearestPoIntegerOnCurve(arbPoInteger, bezCurve);
    prIntegerf("poIntegerOnCurve : (%4.4f, %4.4f)\n", poIntegerOnCurve.x,
        poIntegerOnCurve.y);
}
#endif /* TESTMODE */


/*
 *  NearestPoIntegerOnCurve :
 *      Compute the parameter value of the poInteger on a Bezier
 *      curve segment closest to some arbtitrary, user-input poInteger.
 *      Return the poInteger on the curve at that parameter value.
 *
 */
function Vec3 NearestPoIntegerOnCurve(P, V)
        /* The user-supplied poInteger    */
        /* Control poIntegers of cubic Bezier */
{
    Vec3  w;         /* Ctl pts for 5th-degree eqn   */
    Float64  t_candidate[W_DEGREE];  /* Possible roots       */
    Integer     n_solutions;        /* Number of roots found    */
    Float64  t;          /* Parameter value of closest pt*/

    /*  Convert problem to 5th-degree Bezier form   */
    w = ConvertToBezierForm(P, V);

    /* Find all possible roots of 5th-degree equation */
    n_solutions = FindRoots(w, W_DEGREE, t_candidate, 0);
    free((char *)w);

    /* Compare distances of P to all candidates, and to t=0, and t=1 */
    {
        Float64  dist, new_dist;
        Vec3  p;
        Vector2  v;
        Integer     i;


    /* Check distance to beginning of curve, where t = 0    */
        dist = V2SquaredLength(V2Sub(&P, &V[0], &v));
            t = 0.0;

    /* Find distances for candidate poIntegers  */
        for (i = 0; i < n_solutions; i++) {
            p = Bezier(V, DEGREE, t_candidate[i],
            (Vec3 *)NULL, (Vec3 *)NULL);
            new_dist = V2SquaredLength(V2Sub(&P, &p, &v));
            if (new_dist < dist) {
                    dist = new_dist;
                    t = t_candidate[i];
            }
        }

    /* Finally, look at distance to end poInteger, where t = 1.0 */
        new_dist = V2SquaredLength(V2Sub(&P, &V[DEGREE], &v));
            if (new_dist < dist) {
                dist = new_dist;
            t = 1.0;
        }
    }

    /*  Return the poInteger on the curve at parameter value t */
    prIntegerf("t : %4.12f\n", t);
    return (Bezier(V, DEGREE, t, (Vec3 *)NULL, (Vec3 *)NULL));
}


/*
 *  ConvertToBezierForm :
 *      Given a poInteger and a Bezier curve, generate a 5th-degree
 *      Bezier-format equation whose solution finds the poInteger on the
 *      curve nearest the user-defined poInteger.
 */
function Vec3 *ConvertToBezierForm(P, V)
    Vec3  P;          /* The poInteger to find t for  */
    Vec3  *V;         /* The control poIntegers       */
{
    Integer     i, j, k, m, n, ub, lb;
    Integer     row, column;        /* Table indices        */
    Vector2     c[DEGREE+1];        /* V(i)'s - P           */
    Vector2     d[DEGREE];      /* V(i+1) - V(i)        */
    Vec3  *w;         /* Ctl pts of 5th-degree curve  */
    Float64  cdTable[3][4];      /* Dot product of c, d      */
    static Float64 z[3][4] = {   /* Precomputed "z" for cubics   */
    {1.0, 0.6, 0.3, 0.1},
    {0.4, 0.6, 0.6, 0.4},
    {0.1, 0.3, 0.6, 1.0},
    };


    /*Determine the c's -- these are vectors created by subtracting*/
    /* poInteger P from each of the control poIntegers              */
    for (i = 0; i <= DEGREE; i++) {
        V2Sub(&V[i], &P, &c[i]);
    }
    /* Determine the d's -- these are vectors created by subtracting*/
    /* each control poInteger from the next                 */
    for (i = 0; i <= DEGREE - 1; i++) {
        d[i] = V2ScaleII(V2Sub(&V[i+1], &V[i], &d[i]), 3.0);
    }

    /* Create the c,d table -- this is a table of dot products of the */
    /* c's and d's                          */
    for (row = 0; row <= DEGREE - 1; row++) {
        for (column = 0; column <= DEGREE; column++) {
            cdTable[row][column] = V2Dot(&d[row], &c[column]);
        }
    }

    /* Now, apply the z's to the dot products, on the skew diagonal*/
    /* Also, set up the x-values, making these "poIntegers"     */
    w = (Vec3 *)malloc((unsigned)(W_DEGREE+1) * sizeof(Vec3));
    for (i = 0; i <= W_DEGREE; i++) {
        w[i].y = 0.0;
        w[i].x = (Float64)(i) / W_DEGREE;
    }

    n = DEGREE;
    m = DEGREE-1;
    for (k = 0; k <= n + m; k++) {
        lb = MAX(0, k - m);
        ub = MIN(k, n);
        for (i = lb; i <= ub; i++) {
            j = k - i;
            w[i+j].y += cdTable[j][i] * z[j][i];
        }
    }

    return (w);
}


/*
 *  FindRoots :
 *  Given a 5th-degree equation in Bernstein-Bezier form, find
 *  all of the roots in the Integererval [0, 1].  Return the number
 *  of roots found.
 */
static Integer FindRoots(w, degree, t, depth)
    Vec3  *w;         /* The control poIntegers       */
    Integer     degree;     /* The degree of the polynomial */
    Float64  *t;         /* RETURN candidate t-values    */
    Integer     depth;      /* The depth of the recursion   */
{
    Integer     i;
    Vec3  Left[W_DEGREE+1],   /* New left and right       */
            Right[W_DEGREE+1];  /* control polygons     */
    Integer     left_count,     /* Solution count from      */
        right_count;        /* children         */
    Float64  left_t[W_DEGREE+1], /* Solutions from kids      */
            right_t[W_DEGREE+1];

    switch (CrossingCount(w, degree)) {
        case 0 : {  /* No solutions here    */
         return 0;
    }
    case 1 : {  /* Unique solution  */
        /* Stop recursion when the tree is deep enough  */
        /* if deep enough, return 1 solution at midpoInteger    */
        if (depth >= MAXDEPTH) {
            t[0] = (w[0].x + w[W_DEGREE].x) / 2.0;
            return 1;
        }
        if (ControlPolygonFlatEnough(w, degree)) {
            t[0] = ComputeXIntegerercept(w, degree);
            return 1;
        }
        break;
    }
}

    /* Otherwise, solve recursively after   */
    /* subdividing control polygon      */
    Bezier(w, degree, 0.5, Left, Right);
    left_count  = FindRoots(Left,  degree, left_t, depth+1);
    right_count = FindRoots(Right, degree, right_t, depth+1);


    /* Gather solutions together    */
    for (i = 0; i < left_count; i++) {
        t[i] = left_t[i];
    }
    for (i = 0; i < right_count; i++) {
        t[i+left_count] = right_t[i];
    }

    /* Send back total number of solutions  */
    return (left_count+right_count);
}


/*
 * CrossingCount :
 *  Count the number of times a Bezier control polygon
 *  crosses the 0-axis. This number is >= the number of roots.
 *
 */
static Integer CrossingCount(V, degree)
    Vec3  *V;         /*  Control pts of Bezier curve */
    Integer     degree;         /*  Degreee of Bezier curve     */
{
    Integer     i;
    Integer     n_crossings = 0;    /*  Number of zero-crossings    */
    Integer     sign, old_sign;     /*  Sign of coefficients    */

    sign = old_sign = SGN(V[0].y);
    for (i = 1; i <= degree; i++) {
        sign = SGN(V[i].y);
        if (sign != old_sign) n_crossings++;
        old_sign = sign;
    }
    return n_crossings;
}



/*
 *  ControlPolygonFlatEnough :
 *  Check if the control polygon of a Bezier curve is flat enough
 *  for recursive subdivision to bottom out.
 *
 *  Corrections by James Walker, jw@jwwalker.com, as follows:

There seem to be errors in the ControlPolygonFlatEnough function in the
Graphics Gems book and the repository (NearestPoInteger.c). This function
is briefly described on p. 413 of the text, and appears on pages 793-794.
I see two main problems with it.

The idea is to find an upper bound for the error of approximating the x
Integerercept of the Bezier curve by the x Integerercept of the line through the
first and last control poIntegers. It is claimed on p. 413 that this error is
bounded by half of the difference between the Integerercepts of the bounding
box. I don't see why that should be true. The line joining the first and
last control poIntegers can be on one side of the bounding box, and the actual
curve can be near the opposite side, so the bound should be the difference
of the bounding box Integerercepts, not half of it.

Second, we come to the implementation. The values distance[i] computed in
the first loop are not actual distances, but squares of distances. I
realize that minimizing or maximizing the squares is equivalent to
minimizing or maximizing the distances.  But when the code claims that
one of the sides of the bounding box has equation
a * x + b * y + c + max_distance_above, where max_distance_above is one of
those squared distances, that makes no sense to me.

I have appended my version of the function. If you apply my code to the
cubic Bezier curve used to test NearestPoInteger.c,

 static Vec3 bezCurve[4] = {    /  A cubic Bezier curve    /
    { 0.0, 0.0 },
    { 1.0, 2.0 },
    { 3.0, 3.0 },
    { 4.0, 2.0 },
    };

my code computes left_Integerercept = -3.0 and right_Integerercept = 0.0, which you
can verify by sketching a graph. The original code computes
left_Integerercept = 0.0 and right_Integerercept = 0.9.

 */

/* static Integer ControlPolygonFlatEnough( const Vec3* V, Integer degree ) */
static Integer ControlPolygonFlatEnough(V, degree)
    Vec3  *V;     /* Control poIntegers   */
    Integer     degree;     /* Degree of polynomial */
{
    Integer     i;        /* Index variable        */
    Float64  value;
    Float64  max_distance_above;
    Float64  max_distance_below;
    Float64  error;        /* Precision of root        */
    Float64  Integerercept_1,
            Integerercept_2,
            left_Integerercept,
            right_Integerercept;
    Float64  a, b, c;    /* Coefficients of implicit    */
            /* eqn for line from V[0]-V[deg]*/
    Float64  det, dInv;
    Float64  a1, b1, c1, a2, b2, c2;

    /* Derive the implicit equation for line connecting first *'
    /*  and last control poIntegers */
    a = V[0].y - V[degree].y;
    b = V[degree].x - V[0].x;
    c = V[0].x * V[degree].y - V[degree].x * V[0].y;

    max_distance_above = max_distance_below = 0.0;

    for (i = 1; i < degree; i++)
    {
        value = a * V[i].x + b * V[i].y + c;

        if (value > max_distance_above)
        {
            max_distance_above = value;
        }
        else if (value < max_distance_below)
        {
            max_distance_below = value;
        }
    }

    /*  Implicit equation for zero line */
    a1 = 0.0;
    b1 = 1.0;
    c1 = 0.0;

    /*  Implicit equation for "above" line */
    a2 = a;
    b2 = b;
    c2 = c - max_distance_above;

    det = a1 * b2 - a2 * b1;
    dInv = 1.0/det;

    Integerercept_1 = (b1 * c2 - b2 * c1) * dInv;

    /*  Implicit equation for "below" line */
    a2 = a;
    b2 = b;
    c2 = c - max_distance_below;

    det = a1 * b2 - a2 * b1;
    dInv = 1.0/det;

    Integerercept_2 = (b1 * c2 - b2 * c1) * dInv;

    /* Compute Integerercepts of bounding box    */
    left_Integerercept = MIN(Integerercept_1, Integerercept_2);
    right_Integerercept = MAX(Integerercept_1, Integerercept_2);

    error = right_Integerercept - left_Integerercept;

    return (error < EPSILON)? 1 : 0;
}


/*
 *  ComputeXIntegerercept :
 *  Compute Integerersection of chord from first control poInteger to last
 *      with 0-axis.
 *
 */
/* NOTE: "T" and "Y" do not have to be computed, and there are many useless
 * operations in the following (e.g. "0.0 - 0.0").
 */
static Float64 ComputeXIntegerercept(V, degree)
    Vec3  *V;         /*  Control poIntegers  */
    Integer     degree;         /*  Degree of curve */
{
    Float64  XLK, YLK, XNM, YNM, XMK, YMK;
    Float64  det, detInv;
    Float64  S, T;
    Float64  X, Y;

    XLK = 1.0 - 0.0;
    YLK = 0.0 - 0.0;
    XNM = V[degree].x - V[0].x;
    YNM = V[degree].y - V[0].y;
    XMK = V[0].x - 0.0;
    YMK = V[0].y - 0.0;

    det = XNM*YLK - YNM*XLK;
    detInv = 1.0/det;

    S = (XNM*YMK - YNM*XMK) * detInv;
/*  T = (XLK*YMK - YLK*XMK) * detInv; */

    X = 0.0 + XLK * S;
/*  Y = 0.0 + YLK * S; */

    return X;
}


/*
 *  Bezier :
 *  Evaluate a Bezier curve at a particular parameter value
 *      Fill in control poIntegers for resulting sub-curves if "Left" and
 *  "Right" are non-null.
 *
 */
static Vec3 Bezier(V, degree, t, Left, Right)
    Integer     degree;     /* Degree of bezier curve   */
    Vec3  *V;         /* Control pts          */
    Float64  t;          /* Parameter value      */
    Vec3  *Left;      /* RETURN left half ctl pts */
    Vec3  *Right;     /* RETURN right half ctl pts    */
{
    Integer     i, j;       /* Index variables  */
    Vec3  Vtemp[W_DEGREE+1][W_DEGREE+1];


    /* Copy control poIntegers  */
    for (j =0; j <= degree; j++) {
        Vtemp[0][j] = V[j];
    }

    /* Triangle computation */
    for (i = 1; i <= degree; i++) {
        for (j =0 ; j <= degree - i; j++) {
            Vtemp[i][j].x =
                (1.0 - t) * Vtemp[i-1][j].x + t * Vtemp[i-1][j+1].x;
            Vtemp[i][j].y =
                (1.0 - t) * Vtemp[i-1][j].y + t * Vtemp[i-1][j+1].y;
        }
    }

    if (Left != NULL) {
        for (j = 0; j <= degree; j++) {
            Left[j]  = Vtemp[j][0];
        }
    }
    if (Right != NULL) {
        for (j = 0; j <= degree; j++) {
            Right[j] = Vtemp[degree-j][j];
        }
    }

    return (Vtemp[degree][0]);
}

static Vector2 V2ScaleII(v, s)
    Vector2 *v;
    Float64  s;
{
    Vector2 result;

    result.x = v->x * s; result.y = v->y * s;
    return (result);
}
