require rig_Math;

struct CurveLocation
{
  Size index;
  Float32 time;
};

inline Integer Integer.clamp(in Integer minval, in Integer maxval){
  return (this < minval ? minval : (this > maxval ? maxval : this));
}


function Float32 _GetClosestPointParamOnSegment(Curve curve, Vec3 point, Float32 startU, Float32 endU, Float32 step )
{
  Float32 minDistance = SCALARINFINITE;
  Float32 minParam = 0.0;

  for( Float32 param = startU; param <= endU; param += step )
  {
    Float32 distance = (point - curve.evalPosM( param )).lengthSquared();

    if( minDistance > distance )
    {
      minDistance = distance;
      minParam = param;
    }
  }

  return minParam;
}


function CurveLocation GetClosestPointParam(Curve curve, Vec3 point, Integer iterations, Float32 startU, Float32 endU, Float32 step )
{
  Integer _iterations = iterations;
  _iterations.clamp(0, 5);
  Float32 _startU = startU;
  Float32 _endU = endU;
  Float32 _step = step;

  Float32 minParam = _GetClosestPointParamOnSegment(curve, point, _startU, _endU, _step );

  for( Integer i = 0; i < _iterations; i++ )
  {
    Float32 searchOffset = pow( 10, - Float32(i+2) );

    _startU = (minParam-searchOffset).clamp(0,1);
    _endU = (minParam+searchOffset).clamp(0,1);
    _step = searchOffset * 0.1;

    minParam = _GetClosestPointParamOnSegment(curve, point, _startU, _endU, _step );
  }
  CurveLocation loc;
  loc.time = minParam;
  loc.index = 0;

  return loc;
}