struct Rotation
{
  Vec3 axis;
  Scalar angle;
};

// default constructor - set to identity
//inline Rotation() {
//  this.setIdentity();
//}

// construct from scalars
inline Rotation(in Scalar x, in Scalar y, in Scalar z, in Scalar angle) {
  this.axis.set(x, y, z);
  this.angle = angle;
}

// construct from scalar and vector
inline Rotation(in Scalar angle, in Vec3 axis) {
  this.axis = axis;
  this.angle = angle;
}

// construct from vector and scalar
inline Rotation(in Vec3 axis, in Scalar angle) {
  this.axis = axis;
  this.angle = angle;
}

// construct from euler angles
//inline Quat(in Euler e) {
//  this.setFromEuler(e);
//}

// setter from scalars
inline Rotation.set!(in Scalar x, in Scalar y, in Scalar z, in Scalar angle) {
  this.axis.set(x, y, z);
  this.angle = angle;
}

// setter from scalar and vector
inline Rotation.set!(in Scalar angle, in Vec3 axis) {
  this.axis = axis;
  this.angle = angle;
}

// setter from vector and scalar
inline Rotation.set!(in Vec3 axis, in Scalar angle) {
  this.axis = axis;
  this.angle = angle;
}

// set this quat to the identity
inline Rotation.setIdentity!() {
  this.axis = Vec3(1.0, 0.0, 0.0);
  this.angle = 0.0;
}

inline Rotation Rotation.setFromQuaternion!(Quat q)
{
  if (q.w > 1)
    q.unit();
  this.angle = 2 * acos(q.w);
  Float32 s = sqrt(1-q.w*q.w);
  if (s < 0.001)
  {
    this.axis.x = q.v.x;
    this.axis.y = q.v.y;
    this.axis.z = q.v.z;
  }
  else
  {
    this.axis.x = q.v.x / s;
    this.axis.y = q.v.y / s;
    this.axis.z = q.v.z / s;
  }
  return this;
}

inline Rotation Rotation.setFromMat33!(Mat33 m)
{
  Float32 x,y,z; // variables for result
  Float32 epsilon = 0.01; // margin to allow for rounding errors
  Float32 epsilon2 = 0.1; // margin to distinguish between 0 and 180 degrees
  // optional check that input is pure rotation, 'isRotationMatrix' is defined at:
  // http://www.euclideanspace.com/maths/algebra/matrix/orthogonal/rotation/
  //assert isRotationMatrix(m) : "not valid rotation matrix" ;// for debugging
  if ((abs(m.row0.y-m.row1.x)< epsilon)
    && (abs(m.row0.z-m.row2.x)< epsilon)
    && (abs(m.row1.z-m.row2.y)< epsilon))
  {
    // singularity found
    // first check for identity matrix which must have +1 for all terms
    //  in leading diagonaland zero in other terms
    if ((abs(m.row0.y+m.row1.x) < epsilon2)
      && (abs(m.row0.z+m.row2.x) < epsilon2)
      && (abs(m.row1.z+m.row2.y) < epsilon2)
      && (abs(m.row0.x+m.row1.y+m.row2.z-3) < epsilon2)) {
      // this singularity is identity matrix so angle = 0
      this.axis.set(0, 1, 0);
      this.angle = 0;
      return this; // zero angle, arbitrary axis
    }
    // otherwise this singularity is angle = 180
    this.angle = PI;
    Float32 xx = (m.row0.x+1)/2;
    Float32 yy = (m.row1.y+1)/2;
    Float32 zz = (m.row2.z+1)/2;
    Float32 xy = (m.row0.y+m.row1.x)/4;
    Float32 xz = (m.row0.z+m.row2.x)/4;
    Float32 yz = (m.row1.z+m.row2.y)/4;
    if ((xx > yy) && (xx > zz)) { // m.row0.x is the largest diagonal term
      if (xx< epsilon)
        {x = 0; y = 0.7071; z = 0.7071;}
      else
        {x = sqrt(xx); y = xy/x; z = xz/x;}
    }
    else if (yy > zz)
    { // m.row1.y is the largest diagonal term
      if (yy< epsilon)
        {x = 0.7071; y = 0; z = 0.7071;}
      else
       { y = sqrt(yy); x = xy/y; z = yz/y;}
    }
    else
    { // m.row2.z is the largest diagonal term so base result on this
      if (zz< epsilon)
        {x = 0.7071; y = 0.7071; z = 0;}
      else
        {z = sqrt(zz); x = xz/z; y = yz/z;}
    }
    this.axis.set(x, y, z);
    return this; // return 180 deg rotation
  }
  // as we have reached here there are no singularities so we can handle normally
  Float32 s = sqrt((m.row2.y - m.row1.z)*(m.row2.y - m.row1.z)
    +(m.row0.z - m.row2.x)*(m.row0.z - m.row2.x)
    +(m.row1.x - m.row0.y)*(m.row1.x - m.row0.y)); // used to normalise
  if (abs(s) < 0.001) s=1;
    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case
  this.angle = acos(( m.row0.x + m.row1.y + m.row2.z - 1)/2);
  x = (m.row2.y - m.row1.z)/s;
  y = (m.row0.z - m.row2.x)/s;
  z = (m.row1.x - m.row0.y)/s;
  this.axis.set(x, y, z);
  return this;
}



