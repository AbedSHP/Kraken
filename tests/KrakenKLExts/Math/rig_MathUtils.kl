require Math;
require Util; //needed for String.isDigit !?

//------------------------------
//   Quaternions
//------------------------------
inline Quat Quat.setFromDirAndUpV!(in Vec3 direction, in Vec3 upvector)
{
  Vec3 xAxis = direction.unit();
  Vec3 toUpV = upvector.unit();
  Vec3 zAxis = toUpV.cross(direction).unit();
  Vec3 yAxis = zAxis.cross(direction).unit();
  Mat33 outOri;
  outOri.setColumns(xAxis, yAxis, zAxis);
  this.setFromMat33(outOri);

  return this;
}

inline Quat Mat44.getQuaternion()
{

    Quat q;
    Float32 w2 = (1 + this.row0.x + this.row1.y +this.row2.z)/4;
    if(w2 > 0)
    {
        q.w = sqrt(w2);
        q.v.x = ( this.row2.y - this.row1.z ) / (4*q.w);
        q.v.y = ( this.row0.z - this.row2.x ) / (4*q.w);
        q.v.z = ( this.row1.x - this.row0.y ) / (4*q.w);
    }
    else
    {
        q.w = 0;
      Float32 x2 = -(this.row1.y + this.row2.z)/2;
      if(x2 >0)
      {
        q.v.x = sqrt(x2);
        q.v.y = this.row0.y / (2*q.v.x);
        q.v.z = this.row0.z / (2*q.v.x);
      }
      else
      {
        q.v.x = 0;
        Float32 y2 = (1 - this.row2.z)/2;
        if(y2 > 0)
        {
          q.v.y = sqrt(y2);
          q.v.z = this.row1.z / (2*q.v.y);
        }
        else
        {
          q.v.y = 0;
          q.v.z = 1;
        }
      }
    }
  return q;
}


inline Quat Mat33.getQuaternion()
{
  Quat q;
  Mat33 _m = this;
  q.w = sqrt( Math_max( 0, 1 + _m.row0.x + _m.row1.y + _m.row2.z ) ) / 2;
  q.v.x = sqrt( Math_max( 0, 1 + _m.row0.x - _m.row1.y - _m.row2.z ) ) / 2;
  q.v.y = sqrt( Math_max( 0, 1 - _m.row0.x + _m.row1.y - _m.row2.z ) ) / 2;
  q.v.z = sqrt( Math_max( 0, 1 - _m.row0.x - _m.row1.y + _m.row2.z ) ) / 2;
  q.v.x *= (_m.row2.y - _m.row1.z ).sign;
  q.v.y *= (_m.row0.z - _m.row2.x ).sign;
  q.v.z *= (_m.row1.x - _m.row0.y ).sign;
  return q;
}


inline Quat Quat.slerp720(in Quat q2,  in Scalar t)
{
  Scalar angle = this.dot(q2);
  Quat _q2 = q2;
  if (angle < 0.0) {
    _q2.v = _q2.v.negate();
    _q2.w *= - 1.0;
  }

  Float32 qDot = this.dot(_q2);
  Float32 dScale1, dScale2;
  // if q1 and target are really close then we can interpolate linerarly.
  if (qDot >= (1 - 1.0e-12)){
    dScale1 = 1 - t;
    dScale2 = t;
  }
  else // use standard spherical linear interpolation
  {
    qDot = Math_min(Math_max(qDot, -1), 1);

    if (-qDot * qDot+ 1 == 0)
      Float32 dAngle = -1;
      //return this;
    else
      dAngle = acos(qDot);

    if (sin(dAngle) !=  0)
      Float32 dFactor = 1 / sin(dAngle);
    else
      dFactor = 0;
      //return this;

    dScale1 = sin((1.0 - t) * dAngle ) * dFactor;
    dScale2 = sin( t * dAngle ) * dFactor;
  }

  return this*dScale1 + _q2*dScale2;
}

//------------------------------
//   Rotations
//------------------------------
inline Rotation Quat.axisAndAngle()
{
  if (this.w > 1)
    this.unit();
  Float32 angle = 2 * acos(this.w);
  Float32 s = sqrt(1-this.w*this.w);
  Vec3 axis;
  if (s < 0.001)
  {
    axis.x = this.v.x;
    axis.y = this.v.y;
    axis.z = this.v.z;
  }
  else
  {
    axis.x = this.v.x / s;
    axis.y = this.v.y / s;
    axis.z = this.v.z / s;
  }
  return Rotation(axis, angle);
}


inline Rotation Mat33.toAxisAngle()
{
  Mat33 m = this;
  Rotation r;
  Float32 x,y,z; // variables for result
  Float32 epsilon = 0.01; // margin to allow for rounding errors
  Float32 epsilon2 = 0.1; // margin to distinguish between 0 and 180 degrees
  // optional check that input is pure rotation, 'isRotationMatrix' is defined at:
  // http://www.euclideanspace.com/maths/algebra/matrix/orthogonal/rotation/
  //assert isRotationMatrix(m) : "not valid rotation matrix" ;// for debugging
  if ((abs(m.row0.y-m.row1.x)< epsilon)
    && (abs(m.row0.z-m.row2.x)< epsilon)
    && (abs(m.row1.z-m.row2.y)< epsilon))
  {
    // singularity found
    // first check for identity matrix which must have +1 for all terms
    //  in leading diagonaland zero in other terms
    if ((abs(m.row0.y+m.row1.x) < epsilon2)
      && (abs(m.row0.z+m.row2.x) < epsilon2)
      && (abs(m.row1.z+m.row2.y) < epsilon2)
      && (abs(m.row0.x+m.row1.y+m.row2.z-3) < epsilon2)) {
      // this singularity is identity matrix so angle = 0
      r.axis.set(0, 1, 0);
      r.angle = 0;
      return r; // zero angle, arbitrary axis
    }
    // otherwise this singularity is angle = 180
    r.angle = PI;
    Float32 xx = (m.row0.x+1)/2;
    Float32 yy = (m.row1.y+1)/2;
    Float32 zz = (m.row2.z+1)/2;
    Float32 xy = (m.row0.y+m.row1.x)/4;
    Float32 xz = (m.row0.z+m.row2.x)/4;
    Float32 yz = (m.row1.z+m.row2.y)/4;
    if ((xx > yy) && (xx > zz)) { // m.row0.x is the largest diagonal term
      if (xx< epsilon)
        {x = 0; y = 0.7071; z = 0.7071;}
      else
        {x = sqrt(xx); y = xy/x; z = xz/x;}
    }
    else if (yy > zz)
    { // m.row1.y is the largest diagonal term
      if (yy< epsilon)
        {x = 0.7071; y = 0; z = 0.7071;}
      else
       { y = sqrt(yy); x = xy/y; z = yz/y;}
    }
    else
    { // m.row2.z is the largest diagonal term so base result on this
      if (zz< epsilon)
        {x = 0.7071; y = 0.7071; z = 0;}
      else
        {z = sqrt(zz); x = xz/z; y = yz/z;}
    }
    r.axis.set(x, y, z);
    return  r; // return 180 deg rotation
  }
  // as we have reached here there are no singularities so we can handle normally
  Float32 s = sqrt((m.row2.y - m.row1.z)*(m.row2.y - m.row1.z)
    +(m.row0.z - m.row2.x)*(m.row0.z - m.row2.x)
    +(m.row1.x - m.row0.y)*(m.row1.x - m.row0.y)); // used to normalise
  if (abs(s) < 0.001) s=1;
    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case
  r.angle = acos(( m.row0.x + m.row1.y + m.row2.z - 1)/2);
  x = (m.row2.y - m.row1.z)/s;
  y = (m.row0.z - m.row2.x)/s;
  z = (m.row1.x - m.row0.y)/s;
  r.axis.set(x, y, z);
  return r;
}

//------------------------------
//   String
//------------------------------

function Float32[] String.toArray!(){
    Integer startPos = 0;
    Float32 array[];
    for (Integer i = 0; i<this.length(); i++){
        String c = this[i];
        if (c == ' ')
          continue;
        else if(( !c.isDigit() &&
                  c != "+" &&
                  c != "-" &&
                  c != "e" &&
                  c != ".") ||
                  i == this.length()-1)
        {
          String numberStr = this.subString(startPos, i);
          array.push(numberStr.toScalar());
          startPos = i+1;
        }
    }
    return array;
}

//------------------------------
//   Vec3
//------------------------------
function Vec3 Vec3.rotateVector!(Vec3 axis, Float32 angle)
{
  this = this * cos(angle)+axis * (axis.dot(this)) * (1-cos(angle))+this.cross(axis) * sin(angle);
  return this;
}


function Vec3 Vec3.projectOnPlane!(Vec3 planeNormal, Boolean normalize)
{
  this = this - (planeNormal*(this.dot(planeNormal)));
  if (normalize)
    this = this.unit();
  return this;
}


//------------------------------
//   Vec4
//------------------------------
function Vec4(Vec3 xyz, Float32 w)
{
  this.x = xyz.x;
  this.y = xyz.y;
  this.z = xyz.z;
  this.t = w;
}

//------------------------------
//   Mat44
//------------------------------
function Mat44(Vec3 x, Vec3 y, Vec3 z, Vec3 position)
{
  this.row0.x = x.x;
  this.row0.y = y.x;
  this.row0.z = z.x;
  this.row0.t = position.x;

  this.row1.x = x.y;
  this.row1.y = y.y;
  this.row1.z = z.y;
  this.row1.t = position.y;

  this.row2.x = x.z;
  this.row2.y = y.z;
  this.row2.z = z.z;
  this.row2.t = position.z;

  this.row3.x = 0.0;
  this.row3.y = 0.0;
  this.row3.z = 0.0;
  this.row3.t = 1.0;
}

function Mat44 Mat44.setFromVec3!(Vec3 x, Vec3 y, Vec3 z, Vec3 position)
{
  this.row0 = Vec4(x, 0.0);
  this.row1 = Vec4(y, 0.0);
  this.row2 = Vec4(z, 0.0);
  this.row3 = Vec4(position, 1.0);
  this = this.transpose();
  return this;
}


//------------------------------
//   Utils
//------------------------------
inline Integer Integer.sign()
{
  return (0 < this? 1:0) - (this < 0? 1:0);
}


inline Integer copysign(Integer a, Integer b)
{
  return a * b.sign();
}


inline Float32 Float32.sign()
{
  return (0 < this? 1:0) - (this < 0? 1:0);
}


inline Float32 copysign(Float32 a, Float32 b)
{
  return a * b.sign();
}


function Float32 poissonRatio(Float32 origLen, Float32 newLen, Float32 ratio)
{
  Float32 outRatio;
  Float32 exponent = -1.0 * ratio;
  Float32 lenDelta = newLen - origLen;
  outRatio = pow(1 + (lenDelta / origLen), exponent);
  return outRatio;
}